architecture(network) ::= <<
-- ----------------------------------------------------------------------------
-- Architecture Declaration
-- ----------------------------------------------------------------------------
architecture rtl of <network.simpleName> is
  <signalInstantiation(network)>
  
  <architectureComponents(network)>
begin
  rcon: entity SystemBuilder.resetController( behavioral )
  generic map( count =\> <length(network.templateData.clockDomainsIndex)> )
  port map( clocks =\> clocks, reset_in =\> RESET, resets =\> resets );
  
  <network.templateData.clockDomainsIndex.keys: {key | clocks(<network.templateData.clockDomainsIndex.(key)>) \<= <key>;}; separator="\n">
  
  <actorsInstatiation(network)>
  <networkConnections(network)>
  <networkPortInstatiation(network)>
end architecture rtl;
>>

signalInstantiation(network) ::= <<
-- --------------------------------------------------------------------------
-- Internal Signals
-- --------------------------------------------------------------------------

-- Clock(s) and Reset signal
signal clocks, resets: std_logic_vector(<length(network.templateData.clockDomainsIndex)> - 1 downto 0);

<internalSignals(network)>
>>

internalSignals(network) ::= <<
-- Network Input Port and Input Port Fanout Signals 
<network.inputs: internalInputSignal(); separator="\n">

-- Network Output Port Signals
<network.outputs: internalOutputSignal(); separator="\n">
-- Actors Fanout and I/O Signals
<network.instances: internalActorSignal(); separator="\n">
>>

internalInputSignal(port) ::= <<
<iSignal("ni",port,true,false,false)>

<iSignal("nif",port,true,true,false)>
>>

internalOutputSignal(port) ::= <<
<iSignal("no",port,true,false,false)>

>>

internalActorSignal(instance) ::= <<
<instance.actor.inputs: {port | <iSignal("ai",port,false,false,instance)>}; separator="\n">
<instance.actor.outputs: {port | <iSignal("aof",port,true,true,instance)>}; separator="\n">

<instance.actor.outputs: {port | <iSignal("ao",port,true,false,instance)>}; separator="\n">

>>

iSignal(type,port,dir,nbrFanout,instance) ::= <<
signal <type>_<if(instance)><instance.id>_<endif><port.name>_DATA : std_logic<if(!port.type.bool)>_vector(<port.type.size> - 1 downto 0)<endif>;
signal <type>_<if(instance)><instance.id>_<endif><port.name>_SEND : std_logic<if(nbrFanout)>_vector(<if(instance)><length(instance.outgoingPortMap.(port))><else><network.templateData.networkPortFanout.(port)><endif> - 1 downto 0)<endif>;
signal <type>_<if(instance)><instance.id>_<endif><port.name>_ACK : std_logic<if(nbrFanout)>_vector(<if(instance)><length(instance.outgoingPortMap.(port))><else><network.templateData.networkPortFanout.(port)><endif> - 1 downto 0)<endif>;
signal <type>_<if(instance)><instance.id>_<endif><port.name>_COUNT : std_logic_vector(15 downto 0);
<if(dir)>signal <type>_<if(instance)><instance.id>_<endif><port.name>_RDY : std_logic<if(nbrFanout)>_vector(<if(instance)><length(instance.outgoingPortMap.(port))><else><network.templateData.networkPortFanout.(port)><endif> - 1 downto 0)<endif>;<endif>
>>

architectureComponents(network) ::= <<
-- --------------------------------------------------------------------------
-- Components of Actors found in the Network
-- --------------------------------------------------------------------------

<network.instances: actorsComponents(); separator="\n">
>>

actorsComponents(instance) ::=<<
<if(instance.actor.native)>
<else>
component <instance.id> is
port(
  -- <instance.id> Input(s)
  <instance.actor.inputs:{port | <componentPort(port=port,dir=true)>}; separator="\n">
  -- <instance.id> Ouput(s)
  <instance.actor.outputs:{port | <componentPort(port=port,dir=false)>}; separator="\n">
  CLK: in std_logic;
  RESET: in std_logic);
end component <instance.id>;
<endif>
>>

componentPort(port,dir) ::= <<
<port.name>_DATA : <if(dir)>in<else>out<endif> std_logic<if(!port.type.bool)>_vector(<port.type.size> - 1 downto 0)<endif>;
<port.name>_SEND : <if(dir)>in<else>out<endif> std_logic;
<port.name>_ACK : <if(dir)>out<else>in<endif> std_logic;
<port.name>_COUNT : <if(dir)>in<else>out<endif> std_logic_vector(15 downto 0);
<if(!dir)>
<port.name>_RDY : in std_logic;
<endif>
>>

actorsInstatiation(network) ::= <<
-- --------------------------------------------------------------------------
-- Actor instances
-- --------------------------------------------------------------------------
<network.instances: actorInstance(); separator="\n">
>>

actorInstance(instance) ::= <<
<if(instance.native)>
-- <instance.id> (System Actor)
i_<instance.id> : entity SystemActors.<instance.id>( behavioral )
<if (instance.parameters)>
generic map(
 	<instance.parameters : {parameter | <systemActorParameter(parameter=parameter.name,value=instance.parameters.(parameter.name))>}; separator=",\n">
)
<endif>
<else>
i_<instance.id> : component <instance.id> 
<endif>
port map(
  -- <instance.id> Input(s)
  <instance.actor.inputs:{port | <actorIOPorts(port=port,dir=true)>}; separator="\n">
  -- <instance.id> Ouput(s)
  <instance.actor.outputs:{port | <actorIOPorts(port=port,dir=false)>}; separator="\n">
  -- Clock domain and reset
  CLK =\> clocks(<getClkIndexInstance(instance)>),
  RESET =\> resets(<getClkIndexInstance(instance)>)   
);
>>

systemActorParameter(parameter, value) ::=<<
<if (value.stringExpr)><parameter> =\> "<value>"<else><parameter> =\> <value><endif>
>>

actorIOPorts(port,dir) ::= <<
<port.name>_DATA =\> <if(dir)>ai<else>ao<endif>_<instance.id>_<port.name>_DATA,
<port.name>_SEND =\> <if(dir)>ai<else>ao<endif>_<instance.id>_<port.name>_SEND,
<port.name>_ACK =\> <if(dir)>ai<else>ao<endif>_<instance.id>_<port.name>_ACK,
<port.name>_COUNT =\> <if(dir)>ai<else>ao<endif>_<instance.id>_<port.name>_COUNT,
<if(!dir)>
<port.name>_RDY =\> <if(dir)>ai<else>ao<endif>_<instance.id>_<port.name>_RDY,
<endif>
>>

getClkIndexInstance(instance) ::= <<
<network.templateData.clockDomainsIndex.(network.templateData.instanceClockDomain.(instance))>
>>

getClkIndexPort(port) ::= <<
<network.templateData.clockDomainsIndex.(network.templateData.portClockDomain.(port))>
>>

networkConnections(network) ::= <<
-- --------------------------------------------------------------------------
-- Fanout and Queue Connections
-- --------------------------------------------------------------------------
-- Network Input Ports Fanout
<network.inputs : {port | <fanout(io="ni",ioFanout="nif",port=port,instance=false)> }; separator="\n">

-- Actors Ouput Ports Fanout
<network.instances : actorFanout(); separator="\n">

-- Queues 
<network.connections : queues(); separator="\n">
>>

actorFanout(instance) ::= <<
<instance.actor.outputs : {port | <fanout(io="ao",ioFanout="aof",port=port,instance=instance)> }; separator="\n">
>>

fanout(io,ioFanout,port,instance) ::= <<
f_<io>_<if(instance)><instance.id>_<endif><port.name> : entity SystemBuilder.Fanout( behavioral )
generic map (fanout => <if(instance)><length(instance.outgoingPortMap.(port))><else><network.templateData.networkPortFanout.(port)><endif>, width => <if(port.type.size)><port.type.size><else>1<endif>)
port map (
  <fSignals(io,port,"In")>
  
  <fSignals(ioFanout,port,"Out")>
  
  CLK => clocks(<if(instance)><getClkIndexInstance(instance)><else><getClkIndexPort(port)><endif>),
  RESET => resets(<if(instance)><getClkIndexInstance(instance)><else><getClkIndexPort(port)><endif>)
);
>>

fSignals(type,port,dir) ::= <<
<dir>_DATA =\> <type>_<if(instance)><instance.id>_<endif><port.name>_DATA,
<dir>_SEND =\> <type>_<if(instance)><instance.id>_<endif><port.name>_SEND,
<dir>_ACK =\> <type>_<if(instance)><instance.id>_<endif><port.name>_ACK,
<dir>_COUNT =\> <type>_<if(instance)><instance.id>_<endif><port.name>_COUNT,
<dir>_RDY =\> <type>_<if(instance)><instance.id>_<endif><port.name>_RDY,
>>

queues(connection) ::= <<
<if(connection.source.port)>
<if(connection.target.instance)>
<queue("ai","nif",connection.source,connection.sourcePort,connection.target,connection.targetPort)>
<endif>
<else>
<if(connection.target.instance)>
<queue("ai","aof",connection.source,connection.sourcePort,connection.target,connection.targetPort)>
<else>
<queue("no","aof",connection.source,connection.sourcePort,connection.target,connection.targetPort)>
<endif>
<endif>
>>

queue(io,ioFanout,source,sourcePort,target,targetPort) ::= <<
q_<io>_<if(target.instance)><target.id>_<targetPort.name><else><target.name><endif> : entity SystemBuilder.Queue<if(network.templateData.connectionsClockDomain.(connection))>_Async<endif>(behavioral)
generic map (length =\> <if(connection.size)><connection.size><else>1<endif>, width =\> <if(target.instance)><if(targetPort.type.size)><targetPort.type.size><else>1<endif><else><if(target.type.size)><target.type.size><else>1<endif><endif>)
port map (
  <qSignals("Out",io,target,targetPort,false,false)>
  <qSignals("In",ioFanout,source,sourcePort,true,true)>
  <queueClocks(connection)>
);
>>

queueClocks(connection) ::= <<
<if(network.templateData.connectionsClockDomain.(connection))>
clk_i =\>clocks(<first(network.templateData.connectionsClockDomain.(connection))>),
reset_i =\>resets(<first(network.templateData.connectionsClockDomain.(connection))>),
clk_o =\>clocks(<rest(network.templateData.connectionsClockDomain.(connection))>),
reset_o =\>resets(<rest(network.templateData.connectionsClockDomain.(connection))>)
<else>
clk => clocks(0),
reset => resets(0)
<endif>
>>

qSignals(dir,type,source,sourcePort,io,nbrFanout) ::= <<
<dir>_DATA =\> <type>_<if(source.instance)><source.id>_<sourcePort.name><else><source.name><endif>_DATA,
<dir>_SEND =\> <type>_<if(source.instance)><source.id>_<sourcePort.name><else><source.name><endif>_SEND<if(nbrFanout)>(<network.templateData.networkPortConnectionFanout.(connection)>)<endif>,
<dir>_ACK =\> <type>_<if(source.instance)><source.id>_<sourcePort.name><else><source.name><endif>_ACK<if(nbrFanout)>(<network.templateData.networkPortConnectionFanout.(connection)>)<endif>,
<dir>_COUNT =\> <type>_<if(source.instance)><source.id>_<sourcePort.name><else><source.name><endif>_COUNT,
<if(io)>
<dir>_RDY =\> <type>_<if(source.instance)><source.id>_<sourcePort.name><else><source.name><endif>_RDY<if(nbrFanout)>(<network.templateData.networkPortConnectionFanout.(connection)>)<endif>,
<endif>
>>


networkPortInstatiation(network) ::= <<
-- --------------------------------------------------------------------------
-- Network Ports Instantiation
-- --------------------------------------------------------------------------

-- Output Port(s) Instantiation
<network.outputs:{port | <networkOutputPortInstatiation(port=port)>}; separator="\n">
-- Intput Port(s) Instantiation
<network.inputs:{port | <networkInputPortInstatiation(port=port)>}; separator="\n">
>>

networkOutputPortInstatiation(port) ::=<<
<port.name>_DATA \<= no_<port.name>_DATA;
<if (!port.native)>
<port.name>_SEND \<= no_<port.name>_SEND;
no_<port.name>_ACK \<= <port.name>_ACK;
<port.name>_COUNT \<= no_<port.name>_COUNT;
no_<port.name>_RDY \<= <port.name>_RDY;
<endif>
>> 

networkInputPortInstatiation(port) ::=<<
ni_<port.name>_DATA \<= <port.name>_DATA;
<if (!port.native)>
ni_<port.name>_SEND \<= <port.name>_SEND;
<port.name>_ACK \<= ni_<port.name>_ACK;
ni_<port.name>_COUNT \<= <port.name>_COUNT;
<port.name>_RDY \<= ni_<port.name>_RDY;
<endif>
>> 

entity(network) ::= <<
-- ----------------------------------------------------------------------------
-- Entity Declaration
-- ----------------------------------------------------------------------------
entity <network.simpleName> is
port(
  <networkPorts(network)>
  -- Clock(s) and Reset
  <network.templateData.clockDomainsIndex.keys: {key | <key>: in std_logic;}; separator="\n">
  RESET: in std_logic);
end entity <network.simpleName>;
>>

networkPorts(network) ::= <<
-- XDF Input port(s)
<network.inputs: {port | <printPorts(port=port, dir1="in",dir2="out")>}; separator="\n">
-- XDF Output port(s)
<network.outputs: {port | <printPorts(port=port, dir1="out",dir2="in")>}; separator="\n">
>>

printPorts(port, dir1, dir2) ::= <<
<if(port.type.bool)>
<port.name>_DATA : <dir1> std_logic;
<else>
<port.name>_DATA : <dir1> std_logic_vector(<port.type.size> - 1 downto 0);
<endif>
<if (!port.native)>
<port.name>_SEND : <dir1> std_logic;
<port.name>_ACK : <dir2> std_logic;
<port.name>_COUNT : <dir1> std_logic_vector(15 downto 0);
<port.name>_RDY : <dir2> std_logic;
<endif>
>>

networkInformation(network) ::= <<
-- ----------------------------------------------------------------------------
-- EPFL - Orc2HDL, CAL to HDL code generator
-- Top level model for <network.simpleName>
-- Generated: <options.currentTime>
-- ----------------------------------------------------------------------------

-- ----------------------------------------------------------------------------
-- Clock Informations on the Network "<network.simpleName>"
--
--  Network input port clock domain:
<network.inputs: ioNetworkInformation(); separator="\n"> 
--  Network output port clock domain:
<network.outputs: ioNetworkInformation(); separator="\n">
--
--  All actor instances clock domains:
<network.instances: insancesInformation(); separator="\n">
--
-- ----------------------------------------------------------------------------
>>

ioNetworkInformation(port) ::=<<
--    <port.name> --\> <network.templateData.portClockDomain.(port)>
>>

insancesInformation(instance) ::=<<
--    <instance.id> (<instance.actor.simpleName>) --\> <network.templateData.instanceClockDomain.(instance)>
>>

printNetwork(network, options) ::= <<
<networkInformation(network)>

library ieee, SystemBuilder;--, SystemActors;
use ieee.std_logic_1164.all;

<entity(network)>

<architecture(network)>
-- ----------------------------------------------------------------------------
-- ----------------------------------------------------------------------------
-- ----------------------------------------------------------------------------
>>
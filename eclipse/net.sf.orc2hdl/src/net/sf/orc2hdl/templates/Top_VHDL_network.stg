///////////////////////////////////////////////////////////////////////////////
// VHDL Top for the XLiM Hardware code generation
// Author: Endri Bezati

///////////////////////////////////////////////////////////////////////////////
// Print Actors Instantiation 
///////////////////////////////////////////////////////////////////////////////

PrintActorsInstantiation(network) ::=<<
<network.instances: {instance | <Operations(actorInstance=instance, numberOfReaders=network.outgoingMap.(instance))>}; separator="\n">
>>


Operations(actorInstance, numberOfReaders) ::=<<
<printActorsPortsInstantiation(actorInstance); separator="\n">
<OutputPortFanOut(numberOfReaders); separator="\n">
>>

///////////////////////////////////////////////////////////////////////////////
// Print Actors Ports Instantiation 


printActorsPortsInstantiation(actorInstance) ::=<<
-- <actorInstance.id> (System Actor)
<if(instance.actor.native)>
i_<actorInstance.id> : entity SystemActors.<actorInstance.id>( behavioral )
<if (actorInstance.actor.parameters)>
generic map(
 	<actorInstance.actor.parameters : {parameter | <printActorsParameters(parameter=parameter.name,value=actorInstance.parameters.(parameter.name))>}; separator=",\n">
)
<endif>
<else>
i_<actorInstance.id> : component <actorInstance.id> 
<endif>
port map(
	-- <instance.id> Input(s)
	<actorInstance.actor.inputs: printActorsPortsInstantiationInputs(); separator="\n">
	-- <actorInstance.id> Ouput(s)
	<actorInstance.actor.outputs: printActorsPortsInstantiationOutputs(); separator="\n">
	
	CLK	=\> clocks(0),
	RESET	=\> resets(0)   
);

>>

printActorsParameters(parameter, value) ::=<<
<if (value.stringExpr)><parameter> =\> "<value>"<else><parameter> =\> <value><endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Print Actors Ports Inputs Instantiation 

printActorsPortsInstantiationInputs(port) ::=<<
<port.name>_DATA =\> ai_<actorInstance.id>_<port.name>_DATA,
<port.name>_SEND =\> ai_<actorInstance.id>_<port.name>_SEND,
<port.name>_ACK =\> ai_<actorInstance.id>_<port.name>_ACK,
<port.name>_COUNT =\> ai_<actorInstance.id>_<port.name>_COUNT,

>>

///////////////////////////////////////////////////////////////////////////////
// Print Actors Ports Outputs Instantiation 

printActorsPortsInstantiationOutputs(port) ::=<<
<port.name>_DATA =\> ao_<actorInstance.id>_<port.name>_DATA,
<port.name>_SEND =\> ao_<actorInstance.id>_<port.name>_SEND,
<port.name>_ACK =\> ao_<actorInstance.id>_<port.name>_ACK,
<port.name>_COUNT =\> ao_<actorInstance.id>_<port.name>_COUNT,
<port.name>_RDY =\> ao_<actorInstance.id>_<port.name>_RDY,
>>

///////////////////////////////////////////////////////////////////////////////
// Print Actors Fanout Ports Instantiation 


OutputPortFanOut(numberOfReaders) ::=<<
<actorInstance.actor.outputs : {port | <printActorsFanOutOutput(port=port, numberOfReaders=numberOfReaders)>}; separator="\n">
>>

printActorsFanOutOutput(port, numberOfReaders) ::=<<
<if (port.native)>
f_ao_<actorInstance.id>_<port.name> : entity SystemBuilder.Native( behavioral )
<else>
f_ao_<actorInstance.id>_<port.name> : entity SystemBuilder.Fanout( behavioral )
<endif>
generic map ( fanout =\> <length(numberOfReaders.(port))>, width =\> <if(port.type.size)><port.type.size><else>1<endif> )
port map (
<if(port.type.bool)>
	In_DATA(0) =\> ao_<actorInstance.id>_<port.name>_DATA,
<else>
	In_DATA =\> ao_<actorInstance.id>_<port.name>_DATA,
<endif>
	In_SEND =\> ao_<actorInstance.id>_<port.name>_SEND,
	In_ACK =\> ao_<actorInstance.id>_<port.name>_ACK,
	In_COUNT =\> ao_<actorInstance.id>_<port.name>_COUNT,
	In_RDY =\> ao_<actorInstance.id>_<port.name>_RDY,

<if(port.type.bool)>
	Out_DATA(0) =\> aof_<actorInstance.id>_<port.name>_DATA,
<else>
	Out_DATA =\> aof_<actorInstance.id>_<port.name>_DATA,
<endif>
	Out_SEND =\> aof_<actorInstance.id>_<port.name>_SEND,
	Out_ACK	=\> aof_<actorInstance.id>_<port.name>_ACK,
	Out_COUNT =\> aof_<actorInstance.id>_<port.name>_COUNT,
	Out_RDY =\> aof_<actorInstance.id>_<port.name>_RDY,

	CLK =\> clocks(0),
	RESET =\> resets(0)
);
>>

NetworkInputFanoutInstantiation(network) ::=<<
<network.inputs: printNetworkFanOutInputInstantiation(); separator="\n">
>>

printNetworkFanOutInputInstantiation(port) ::=<<
<if (port.native)>
f_ni_<port.name> : entity SystemBuilder.Native( behavioral )
<else>
f_ni_<port.name> : entity SystemBuilder.Fanout( behavioral )
<endif>
generic map ( fanout =\> <network.templateData.countNetwokPortBroadcastMap.(port)>, width =\> <if(port.type.size)><port.type.size><else>1<endif> )
port map (
<if(port.type.bool)>
	In_DATA(0) =\> ni_<port.name>_DATA,
<else>
	In_DATA =\> ni_<port.name>_DATA,
<endif>
	In_SEND =\> ni_<port.name>_SEND,
	In_ACK =\> ni_<port.name>_ACK,
	In_COUNT =\> ni_<port.name>_COUNT,
	In_RDY =\> ni_<port.name>_RDY,

<if(port.type.bool)>
	Out_DATA(0) =\> nif_<port.name>_DATA,
<else>
	Out_DATA =\> nif_<port.name>_DATA,
<endif>
	Out_SEND =\> nif_<port.name>_SEND,
	Out_ACK =\> nif_<port.name>_ACK,
	Out_COUNT =\> nif_<port.name>_COUNT,
	Out_RDY =\> nif_<port.name>_RDY,

	CLK   =\> clocks(0),
	RESET =\> resets(0)
);

>>

///////////////////////////////////////////////////////////////////////////////
// Assign FIFOs
///////////////////////////////////////////////////////////////////////////////
AssignFifos(edges) ::= <<
<edges: assignFifo()>
>>

assignFifo(edge) ::= <<
<tryAssignFifo(edge=edge, src=network.sourceMap.(edge), tgt=network.targetMap.(edge))>
>>

tryAssignFifo(edge, src, tgt) ::= <<
<if (src.instance)>
 <if (tgt.instance)>
<doAssignFifo(source=src.instance, sourcePort=edge.source, target=tgt.instance, targetPort=edge.target)>
 <else>
<assignIn(source=src.instance, sourcePort=edge.source)>
 <endif>
<else>
 <if (tgt.instance)>
<assignOut(target=tgt.instance, targetPort=edge.target)>
 <endif>
<endif>

>>

printAssignOut(name,type,target,port) ::= <<
Out_<name> =\> <type>_<target.id>_<port.name>_<name>,
>>

printAssignIn(name,type,source,port) ::= <<
In_<name> =\> <type>_<source.id>_<port.name>_<name>( <if(network.templateData.countBroadcastConnectionsMap.(edge))><network.templateData.countBroadcastConnectionsMap.(edge)><else>0<endif> ),
>>

printAssignInstatiationIn(type,target,port) ::= <<
<if(port.type.bool)>
	Out_DATA(0) =\> <type>_<target.id>_<port.name>_DATA,
<else>
	Out_DATA =\> <type>_<target.id>_<port.name>_DATA,
<endif>
	<printAssignOut("SEND",type,target,port)>
	<printAssignOut("ACK",type,target,port)>
	<printAssignOut("COUNT",type,target,port)>
>>

printAssignInstatiationOut(type,source,port) ::= <<
<if(port.type.bool)>
	In_DATA(0) =\> <type>_<source.id>_<port.name>_DATA,
<else>
	In_DATA =\> <type>_<source.id>_<port.name>_DATA,
<endif>
	<printAssignIn("SEND",type,source,port)>
	<printAssignIn("ACK",type,source,port)>
	In_COUNT =\> <type>_<source.id>_<port.name>_COUNT,
	<printAssignIn("RDY",type,source,port)>
>>

doAssignFifo(source, sourcePort, target, targetPort) ::= <<
q_ai_<target.id>_<targetPort.name> : entity SystemBuilder.Queue( behavioral )
generic map( length =\> <if(edge.size)><edge.size><else>1<endif>, width =\> <if(sourcePort.type.size)><sourcePort.type.size><else>1<endif> )
port map (
<printAssignInstatiationIn("ai",target,targetPort)>

<printAssignInstatiationOut("aof",source,sourcePort)>

	clk =\> clocks(0),
	reset =\> resets(0)
);  
  
>>

assignIn(source, sourcePort) ::= <<
<if (!tgt.port.native)>
q_no_<tgt.port.name> : entity SystemBuilder.Queue( behavioral )
generic map( length =\> <if(edge.size)><edge.size><else>1<endif>, width =\> <if(sourcePort.type.size)><sourcePort.type.size><else>1<endif> )
port map (
<if(sourcePort.type.bool)>
 	Out_DATA(0) =\> no_<tgt.port.name>_DATA,
<else>
	Out_DATA =\> no_<tgt.port.name>_DATA,
<endif>
	Out_SEND =\> no_<tgt.port.name>_SEND,
	Out_ACK =\> no_<tgt.port.name>_ACK,
	Out_COUNT =\> no_<tgt.port.name>_COUNT,
	
<if(sourcePort.type.bool)>
	In_DATA(0) =\> aof_<source.id>_<sourcePort.name>_DATA,
<else>
	In_DATA =\> aof_<source.id>_<sourcePort.name>_DATA,
<endif>
	In_SEND =\> aof_<source.id>_<sourcePort.name>_SEND( <if(network.numberOfConnectionReadersMap.(edge))><network.numberOfConnectionReadersMap.(edge)><else>0<endif> ),
	In_ACK =\> aof_<source.id>_<sourcePort.name>_ACK( <if(network.numberOfConnectionReadersMap.(edge))><network.numberOfConnectionReadersMap.(edge)><else>0<endif> ),
	In_COUNT =\> aof_<source.id>_<sourcePort.name>_COUNT,
	In_RDY =\> aof_<source.id>_<sourcePort.name>_RDY( <if(network.numberOfConnectionReadersMap.(edge))><network.numberOfConnectionReadersMap.(edge)><else>0<endif> ),

	clk =\> clocks(0),
	reset =\> resets(0)
);
<endif>
>>


assignOut(target, targetPort) ::= <<
<if (!targetPort.native)>
q_ai_<target.id>_<targetPort.name> : entity SystemBuilder.Queue( behavioral )
generic map( length =\> <if(edge.size)><edge.size><else>1<endif>, width =\> <if(targetPort.type.size)><targetPort.type.size><else>1<endif> )

port map (
<if(targetPort.type.bool)>
	Out_DATA(0) =\> ai_<target.id>_<targetPort.name>_DATA,
<else>
	Out_DATA =\> ai_<target.id>_<targetPort.name>_DATA,
<endif>
	Out_SEND =\> ai_<target.id>_<targetPort.name>_SEND,
	Out_ACK =\> ai_<target.id>_<targetPort.name>_ACK,
	Out_COUNT =\> ai_<target.id>_<targetPort.name>_COUNT,
	
<if(targetPort.type.bool)>
	In_DATA(0) =\> nif_<src.port.name>_DATA,
<else>
	In_DATA =\> nif_<src.port.name>_DATA,
<endif>
	In_SEND =\> nif_<src.port.name>_SEND( <if(network.templateData.countBroadcastConnectionsMap.(edge))><network.templateData.countBroadcastConnectionsMap.(edge)><else>0<endif> ),
	In_ACK =\> nif_<src.port.name>_ACK( <if(network.templateData.countBroadcastConnectionsMap.(edge))><network.templateData.countBroadcastConnectionsMap.(edge)><else>0<endif> ),
	In_COUNT =\> nif_<src.port.name>_COUNT,
	In_RDY =\> nif_<src.port.name>_RDY( <if(network.templateData.countBroadcastConnectionsMap.(edge))><network.templateData.countBroadcastConnectionsMap.(edge)><else>0<endif> ),


	clk =\> clocks(0),
	reset =\> resets(0)
);
<endif>
>>
///////////////////////////////////////////////////////////////////////////////
// Print Network Port Instantiation 
///////////////////////////////////////////////////////////////////////////////

PrintNetworkPortsInstantiation(network) ::=<<
-- Network Output Port(s) Instantiation
<network.outputs: printNetworkOutputPortsInstantiation(); separator="\n">

-- Network Intput Port(s) Instantiation
<network.inputs: printNetworkInputPortsInstantiation(); separator="\n">
>>

///////////////////////////////////////////////////////////////////////////////
// Print Network Output Port(s) Instantiation

printNetworkOutputPortsInstantiation(port) ::=<<
<port.name>_DATA \<= no_<port.name>_DATA;
<if (!port.native)>
<port.name>_SEND \<= no_<port.name>_SEND;
no_<port.name>_ACK \<= <port.name>_ACK;
<port.name>_COUNT \<= no_<port.name>_COUNT;
no_<port.name>_RDY \<= <port.name>_RDY;<\n>
<endif>
>> 

///////////////////////////////////////////////////////////////////////////////
// Print Network Input Port(s) Instantiation

printNetworkInputPortsInstantiation(port) ::=<<
ni_<port.name>_DATA \<= <port.name>_DATA;
<if (!port.native)>
ni_<port.name>_SEND \<= <port.name>_SEND;
<port.name>_ACK \<= ni_<port.name>_ACK;
ni_<port.name>_COUNT \<= <port.name>_COUNT;
<port.name>_RDY \<= ni_<port.name>_RDY;<\n>
<endif>
>> 


///////////////////////////////////////////////////////////////////////////////
// Print Network Components
///////////////////////////////////////////////////////////////////////////////

PrintComponents(network) ::=<<
<network.instances: printActorsComponents(); separator="\n">
>>

///////////////////////////////////////////////////////////////////////////////
// Print Actors Components

printActorsComponents(instance) ::=<<
<if(instance.actor.native)>
<else>
component <instance.id> is
port(
	-- <instance.id> Input(s)
	<instance.actor.inputs: printActorsComponentsInputs(); separator="\n">
	-- <instance.id> Ouput(s)
	<instance.actor.outputs: printActorsComponentsOutputs(); separator="\n">
	
	CLK: in std_logic;
	RESET: in std_logic );
end component <instance.id>;
<endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Print the Inputs of the Actor Components

printActorsComponentsInputs(port) ::=<<
<if(port.type.bool)>
<port.name>_DATA : in std_logic;
<else>
<port.name>_DATA : in std_logic_vector(<port.type.size> - 1 downto 0);
<endif>
<port.name>_SEND : in std_logic;
<port.name>_ACK : out std_logic;
<port.name>_COUNT : in std_logic_vector(15 downto 0);
>>

///////////////////////////////////////////////////////////////////////////////
// Print the Outputs of the Actor Components

printActorsComponentsOutputs(port) ::=<<
<if(port.type.bool)>
<port.name>_DATA : out std_logic;
<else>
<port.name>_DATA : out std_logic_vector(<port.type.size> - 1 downto 0);
<endif>
<port.name>_SEND : out std_logic;
<port.name>_ACK : in std_logic;
<port.name>_COUNT : out std_logic_vector(15 downto 0);
<port.name>_RDY : in std_logic;
>>

///////////////////////////////////////////////////////////////////////////////
// Print Signals
///////////////////////////////////////////////////////////////////////////////

PrintSignals(network) ::= <<
-- Input Port Signals
<network.inputs:{ port | <printInputPortsSignals(port=port)>}; separator="\n">
-- Output Port Signals
<network.outputs:{ port | <printOutputPortsSignals(port=port)>}; separator="\n">
-- Actors I/O Signals
<network.instances: { instance | <printActorsSignals(instance=instance,numberOfReaders=network.outgoingMap.(instance))>}; separator="\n">
>>

///////////////////////////////////////////////////////////////////////////////
// Network Input Signals

printInputPortsSignals(port) ::=<<
<if(port.type.bool)>
signal ni_<port.name>_DATA : std_logic;<\n>
<else>
signal ni_<port.name>_DATA : std_logic_vector(<port.type.size> - 1 downto 0);<\n>
<endif>
signal ni_<port.name>_SEND : std_logic;
signal ni_<port.name>_ACK : std_logic;
signal ni_<port.name>_COUNT : std_logic_vector(15 downto 0);
signal ni_<port.name>_RDY : std_logic;

<if(port.type.bool)>
signal nif_<port.name>_DATA : std_logic;
<else>
signal nif_<port.name>_DATA : std_logic_vector(<port.type.size> - 1 downto 0);
<endif> 
signal nif_<port.name>_SEND : std_logic_vector(<if(network.templateData.countNetwokPortBroadcastMap.(port))><network.templateData.countNetwokPortBroadcastMap.(port)><else>1<endif> - 1 downto 0);
signal nif_<port.name>_ACK : std_logic_vector(<if(network.templateData.countNetwokPortBroadcastMap.(port))><network.templateData.countNetwokPortBroadcastMap.(port)><else>1<endif> - 1 downto 0);
signal nif_<port.name>_COUNT : std_logic_vector(15 downto 0);
signal nif_<port.name>_RDY : std_logic_vector(<if(network.templateData.countNetwokPortBroadcastMap.(port))><network.templateData.countNetwokPortBroadcastMap.(port)><else>1<endif> - 1 downto 0);<\n>

>>

///////////////////////////////////////////////////////////////////////////////
// Network Output Signals

printOutputPortsSignals(port) ::=<<
<if(port.type.bool)>
signal no_<port.name>_DATA : std_logic;<\n>
<else>
signal no_<port.name>_DATA : std_logic_vector(<port.type.size> - 1 downto 0);<\n>
<endif>
signal no_<port.name>_SEND : std_logic;
signal no_<port.name>_ACK : std_logic;
signal no_<port.name>_COUNT : std_logic_vector(15 downto 0);
signal no_<port.name>_RDY : std_logic;<\n>
>>

///////////////////////////////////////////////////////////////////////////////
// Actors Input / Output Signals

printActorsSignals(instance,numberOfReaders) ::=<<
<instance.actor.outputs: {port | <printActorSigOutput(port=port,numberOfReaders=numberOfReaders)>};  separator="\n">
<instance.actor.inputs: printActorSigInput()>
>> 

///////////////////////////////////////////////////////////////////////////////
// Actors Input Signals

printActorSigInput(port) ::= <<
<if(port.type.bool)>
signal ai_<instance.id>_<port.name>_DATA : std_logic;
<else>
signal ai_<instance.id>_<port.name>_DATA : std_logic_vector(<port.type.size> - 1 downto 0);
<endif>
signal ai_<instance.id>_<port.name>_SEND : std_logic;
signal ai_<instance.id>_<port.name>_ACK : std_logic;
signal ai_<instance.id>_<port.name>_COUNT : std_logic_vector(15 downto 0);<\n>
>>

///////////////////////////////////////////////////////////////////////////////
// Actors Ouput Signals

printActorSigOutput(port,numberOfReaders) ::= <<
<if(port.type.bool)>
signal ao_<instance.id>_<port.name>_DATA : std_logic;
<else>
signal ao_<instance.id>_<port.name>_DATA : std_logic_vector(<port.type.size> - 1 downto 0);
<endif>
signal ao_<instance.id>_<port.name>_SEND : std_logic;
signal ao_<instance.id>_<port.name>_ACK : std_logic;
signal ao_<instance.id>_<port.name>_COUNT : std_logic_vector(15 downto 0);
signal ao_<instance.id>_<port.name>_RDY : std_logic;


<if(port.type.bool)>
signal aof_<instance.id>_<port.name>_DATA : std_logic;
<else>
signal aof_<instance.id>_<port.name>_DATA : std_logic_vector(<port.type.size> - 1 downto 0);
<endif> 
signal aof_<instance.id>_<port.name>_SEND : std_logic_vector(<if(numberOfReaders.(port))><length(numberOfReaders.(port))><else>1<endif> - 1 downto 0);
signal aof_<instance.id>_<port.name>_ACK : std_logic_vector(<if(numberOfReaders.(port))><length(numberOfReaders.(port))><else>1<endif> - 1 downto 0);
signal aof_<instance.id>_<port.name>_COUNT : std_logic_vector(15 downto 0);
signal aof_<instance.id>_<port.name>_RDY : std_logic_vector(<if(numberOfReaders.(port))><length(numberOfReaders.(port))><else>1<endif> - 1 downto 0);<\n>
>>

///////////////////////////////////////////////////////////////////////////////
// Print Top Network I/O
///////////////////////////////////////////////////////////////////////////////

printNetworkPorts(network) ::= <<
<network.inputs: {port | <printNetPorts(port=port, dir1="in",dir2="out")>}; separator="\n">
<network.outputs: {port | <printNetPorts(port=port, dir1="out",dir2="in")>}; separator="\n">
>>

printNetPorts(port, dir1, dir2) ::= <<
<if(port.type.bool)>
<port.name>_DATA : <dir1> std_logic;<\n>
<else>
<port.name>_DATA : <dir1> std_logic_vector(<port.type.size> - 1 downto 0);<\n>
<endif>
<if (!port.native)>
<port.name>_SEND : <dir1> std_logic;
<port.name>_ACK : <dir2> std_logic;
<port.name>_COUNT : <dir1> std_logic_vector(15 downto 0);
<port.name>_RDY : <dir2> std_logic;
<endif>

>>

///////////////////////////////////////////////////////////////////////////////
// Print Top Network
///////////////////////////////////////////////////////////////////////////////

printNetworkInformation(network) ::=<<
-- ----------------------------------------------------------------------------------
-- Top level model for <network.simpleName>
-- Generated: <options.currentTime>
-- ----------------------------------------------------------------------------------

-- ----------------------------------------------------------------------------------
--
--  All actor instances:
<network.instances: printInsancesName(); separator="\n">
--
-- ----------------------------------------------------------------------------------
>>

printInsancesName(instance) ::=<<
--    <instance.id> (<instance.actor.name>) --\> CLK
>>

printArchitectureClockDomains(network) ::=<<
>>

network(network, options) ::= <<
<printNetworkInformation(network)>

library ieee, SystemBuilder;--, SystemActors;
use ieee.std_logic_1164.all;

-- ----------------------------------------------------------------------------------
-- Entity Declaration
-- ----------------------------------------------------------------------------------

entity <network.simpleName> is
port(
	<printNetworkPorts(network)>
	
	CLK:  	in std_logic;
	RESET:	in std_logic);
end entity <network.simpleName>;

-- ----------------------------------------------------------------------------------
-- Architecture Declaration
-- ----------------------------------------------------------------------------------

architecture rtl of <network.simpleName> is
	
	-- ----------------------------------------------------------------------------------
	-- Signal Instantiation
	-- ----------------------------------------------------------------------------------
	
	-- Clock and Reset signal
	signal clocks, resets: std_logic_vector(0 downto 0);
	
	<PrintSignals(network); separator="\n">
	
	-- ----------------------------------------------------------------------------------
	-- Components of Actors found in the Network
	-- ----------------------------------------------------------------------------------
	
	<PrintComponents(network); separator="\n">
	
begin
	rcon: entity SystemBuilder.resetController( behavioral )
	generic map( count =\> 1 )
	port map( clocks =\> clocks, reset_in =\> RESET, resets =\> resets );

  	clocks(0) \<= CLK;
  	
	---------------------------------------------------------------------------
	-- Actors Instantiation 
	---------------------------------------------------------------------------
  	
  	<PrintActorsInstantiation(network)>
  	<AssignFifos(network.connections)>
  	<NetworkInputFanoutInstantiation(network)>
  	
  	---------------------------------------------------------------------------
	-- Network Ports Instantiation 
	---------------------------------------------------------------------------
	
	<PrintNetworkPortsInstantiation(network); separator="\n">

end architecture rtl;

-- ----------------------------------------------------------------------------------
-- ----------------------------------------------------------------------------------
-- ----------------------------------------------------------------------------------
>>
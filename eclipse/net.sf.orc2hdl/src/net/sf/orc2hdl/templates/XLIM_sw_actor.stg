BinOp ::= [
	"BITAND":"bitand",
	"BITOR":"bitor",
	"BITXOR":"bitxor",
	"DIV":"$div",
	"DIV_INT":"$div",
	"EQ":"$eq",
	"EXP":"exp",
	"GE":"$ge",
	"GT":"$gt",
	"LE":"$le",
	"LOGIC_AND":"$and",
	"LOGIC_OR":"$or",
	"LT":"$lt",
	"MINUS":"$sub",
	"MOD":"$mod",
	"NE":"$ne",
	"PLUS":"$add",
	"SHIFT_LEFT":"lshift",
	"SHIFT_RIGHT":"rshift",
	"TIMES":"$mul"
]

UnaryOp ::= [
	"BITNOT":"bitnot",
	"LOGIC_NOT":"$not",
	"MINUS":"$negate",
	"NUM_ELTS":"$size"
]


///////////////////////////////////////////////////////////////////////////////
// Ports
///////////////////////////////////////////////////////////////////////////////

// "actorPort() function"
// Print the actor-port template for a specific I/O

actorPort(port, dir) ::= <<
<if (port.type.bool)
>\<actor-port dir="<dir>" name="<port.name>" size="1" typeName="<port.type>"/\><
else
>\<actor-port dir="<dir>" name="<port.name>" size="<port.type.size>" typeName="<port.type>"/\><
endif>
>>

// "actorPorts() function"
// For each input or output retrieve the list of the I/Os
// and attribute to the variable "port" the name of the I/O 

actorPorts() ::= <<
\<!-- Ports --\>
\<!-- Input Ports --\>
<instance.actor.inputs: {port|<actorPort(port=port, dir="in")>}; separator="\n">
\<!-- Output Ports --\>
<instance.actor.outputs: {port|<actorPort(port=port, dir="out")>}; separator="\n">
>>

///////////////////////////////////////////////////////////////////////////////
// State Variables
///////////////////////////////////////////////////////////////////////////////

initVariable(type, value) ::= <<
<if(value.class.array)
>\<initValue typeName="List"\>
	<value: {elt | <initVariable(type=type.type, value=elt)>}; separator="">\</initValue\>
<else
>\<initValue size="<if (type.bool)>1<else><type.size><endif>" typeName="<type>" value="<if (type.bool)><if (value)>1<else>0<endif><else><value><endif>"/\>
<endif>
>>

stateVar(var) ::= <<
<if(var.initialized)>\<stateVar name="<var.name>" sourceName="<var.name>"\>
	<initVariable(type=var.type, value=var.value)>\</stateVar\>
<else>
<typeDefLocal(var)>
\<stateVar name="<var.name>" sourceName="<var.name>" typeName="<if(var.type.list)><var.name>_typedef<else><var.type><endif>"<if(!var.type.list)> size="<if (var.type.bool)>1<else><var.type.size><endif>"<endif>/\>
<endif>
>>

stateVars() ::= <<
\<!-- State Variables --\>
<instance.actor.stateVars: stateVar()>
>>


///////////////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////////////

expression(expr) ::= <<
<if(expr.binaryExpr)><printBinaryExpr(expr)><
elseif(expr.unaryExpr)><printUnaryExpr(expr)><
elseif(expr.intExpr)><printIntExpr(expr)><
elseif(expr.booleanExpr)><printBoolExpr(expr)><
elseif(expr.varExpr)><printVarExpr(expr)><endif>
>>


printBinaryExpr(expr) ::= <<
\<operation kind="<BinOp.(expr.op)>"\>
	<untypedPort(dir="in", source=expr.e1.use.variable)>
	<untypedPort(dir="in", source=expr.e2.use.variable)>
	<typedPort(dir="out", type=op.target.variable.type, source=op.target.variable)>
\</operation\>
>>

printUnaryExpr(expr) ::= <<
\<!-- Unary expression is unsupported --\>
>>

printIntExpr(expr) ::= <<
\<operation kind="$literal_Integer" value="<expr>"\>
	<typedPort(dir="out", type=op.target.variable.type, source=op.target.variable)>
\</operation\>
>>

printBoolExpr(expr) ::= <<
\<operation kind="$literal_Integer" value="<expr>"\>
	<typedPort(dir="out", type=op.target.variable.type, source=op.target.variable)>
\</operation\>
>>

printVarExpr(expr) ::= <<
\<operation kind="noop"\>
	<untypedPort(dir="in", source=expr.use.variable)>
	<typedPort(dir="out", type=op.target.variable.type, source=op.target.variable)>
\</operation\>
>>

///////////////////////////////////////////////////////////////////////////////
// XLIM Port
///////////////////////////////////////////////////////////////////////////////

untypedPort(dir, source, extension="") ::= <<
\<port dir="<dir>" source="<source.indexedName><extension>"/\>
>>

typedPort(dir, type, source, extension="") ::= <<
<if(!type.list || source.global)
>\<port dir="<dir>" size="<if(type.bool)>1<else><type.size><endif>" source="<source.indexedName><extension>" typeName="<type>"/\><
else
>\<port dir="<dir>" source="<source.indexedName><extension>" typeName="<source.indexedName><extension>_typedef"/\><
endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Instructions
///////////////////////////////////////////////////////////////////////////////

instruction(op) ::= <<
<if(op.call)><printCall(op)><
elseif(op.load)><printLoad(op)><
elseif(op.store)><printStore(op)><
elseif(op.assign)><printAssign(op)><
elseif(op.phi)><printPhiAssignment(op)><
elseif(op.return)><printReturn(op)><
elseif(op.instAssignIndex)><printAssignIndex(op)><
elseif(op.instCast)><printCast(op)><
elseif(op.instTernary)><printTernaryOperation(op)><endif>
>>

printCall(op) ::= <<
\<!-- Call is unsupported --\>
>>

printLoad(op) ::= <<
\<!-- <op> --\>
<if(op.source.variable.type.list)
>\<operation kind="var_ref" name="<op.source.variable.name>"\>
	<op.indexes: { index | <untypedPort(dir="in", source=index.use.variable)> }; separator="\n">
	<typedPort(dir="out", type=op.target.variable.type, source=op.target.variable)>
\</operation\><
else
>\<operation kind="noop"\>
	<untypedPort(dir="in", source=op.source.variable)>
	<typedPort(dir="out", type=op.target.variable.type, source=op.target.variable)>
\</operation\><
endif>
>>

printStore(op) ::= <<
\<!-- <op> --\>
<if (op.target.variable.global || op.target.variable.type.list)
>\<operation kind="assign" target="<op.target.variable.name>"\>
	<op.indexes: { index | <untypedPort(dir="in", source=index.use.variable)> }; separator="\n">
	<untypedPort(dir="in", source=op.value.use.variable)>
\</operation\><
else
>\<operation kind="noop"\>
	<untypedPort(dir="in", source=op.value.use.variable)>
	<typedPort(dir="out", type=op.value.type, source=op.target.variable)>
\</operation\><
endif>
>>

printAssign(op) ::= <<
\<!-- <op> --\>
<expression(op.value)>
>>


printPhiAssignment(op) ::= <<
\<PHI\>
	<untypedPort(dir="in", source=first(op.values).use.variable)>
	<untypedPort(dir="in", source=last(op.values).use.variable)>
	<typedPort(dir="out", type=op.target.variable.type, source=op.target.variable)>
\</PHI\>
>>

printReturn(return) ::= <<
<if(return.value)
>\<!-- <op> --\>
\<operation kind="noop"\>
	<untypedPort(dir="in", source=return.value.use.variable)>
	\<port dir="out" size="1" source="<procedure.name>_go" typeName="bool"/\>
\</operation\><
endif>
>>

printAssignIndex(op) ::= <<
<if(rest(op.indexes))
>\<!-- <op> --\>
<sizeDeclare(target=op.target.variable, type=op.listType)>
\<operation kind="noop"\>
	<untypedPort(dir="in", source=first(op.indexes).use.variable)>
	<typedPort(dir="out", type=op.target.variable.type, source=op.target.variable, extension="_tmp_0")>
\</operation\>
<flatIndexes(indexes=rest(op.indexes), target=op.target.variable, lastIndex="0", indexMap=op.expressionToIndexMap)><
else
>\<operation kind="noop"\>
	<untypedPort(dir="in", source=first(op.indexes).use.variable)>
	<typedPort(dir="out", type=op.target.variable.type, source=op.target.variable)>
\</operation\><
endif>
>>

printTernaryOperation(op) ::= <<
\<!-- <op> --\>
\<operation kind="$selector"\>
	<untypedPort(dir="in", source=op.conditionValue.use.variable)>
	<untypedPort(dir="in", source=op.trueValue.use.variable)>
	<untypedPort(dir="in", source=op.falseValue.use.variable)>
	<typedPort(dir="out", type=op.target.variable.type, source=op.target.variable)>
\</operation\>
>>

printCast(op) ::= << 
\<!-- <op> --\>
\<operation kind="cast"\> 
	<untypedPort(dir="in", source=op.source.variable)> 
	<typedPort(dir="out", type=op.target.variable.type, source=op.target.variable)> 
\</operation\> 
>> 

///////////////////////////////////////////////////////////////////////////////
// FIFO Operations
///////////////////////////////////////////////////////////////////////////////

printPeeks(peekedMap) ::= <<
<peekedMap.keys: { port | <printPeeksPerPort(port, peekedMap.(port))> }; separator="\n">
>>

printPeeksPerPort(port, indexToTargetMap) ::= <<
<indexToTargetMap.keys : { index | <printPeek(port, indexToTargetMap.(index), index)> }; separator="\n">
>>

printPeek(port, target, tokenIndex) ::= <<
\<operation kind="$literal_Integer" value="<tokenIndex>"\>
	\<port dir="out" size="32" source="peek_<action.scheduler.name>_<target.name>_<tokenIndex>" typeName="int"/\>
\</operation\>
\<operation kind="pinPeek" portName="<port.name>" removable="no"\>
	\<port dir="in" source="peek_<action.scheduler.name>_<target.name>_<tokenIndex>"/\>
	<typedPort(dir="out", type=port.type, source=target)>
\</operation\>
>>

printRead(port, target, numTokens) ::= <<
\<!-- note kind="consumptionRates" name="<port.name>" value="<numTokens>"/--\>
\<operation kind="pinRead" portName="<port.name>" removable="no" style="simple"\>
	<typedPort(dir="out", type=target.type, source=target)>
\</operation\>
>>

printWrite(port, source, numTokens) ::= <<
\<operation kind="pinWrite" portName="<port.name>" style="simple"\>
	<untypedPort(dir="in", source=source)>
\</operation\>
\<!--note kind="productionRates" name="<port.name>" value="<numTokens>"/--\>
>>

///////////////////////////////////////////////////////////////////////////////
// Flatten indexes
///////////////////////////////////////////////////////////////////////////////

flatIndexes(indexes,target,lastIndex,indexMap) ::= <<
\<operation kind="$mul"\>
	\<port dir="in" source="<target.name>_tmp_<lastIndex>"/\>
	\<port dir="in" source="<target.name>_size_<indexMap.(first(indexes))>"/\>
	\<port dir="out" size="32" source="<target.name>_tmpMul_<indexMap.(first(indexes))>" typeName="int"/\>
\</operation\>
\<operation kind="$add"\>
	\<port dir="in" source="<target.name>_tmpMul_<indexMap.(first(indexes))>"/\>
	\<port dir="in" source="<first(indexes)>"/\>
	\<port dir="out" size="32" source="<target.name>_tmp_<indexMap.(first(indexes))>" typeName="int"/\>
\</operation\>
<if(rest(indexes))
><flatIndexes(indexes=rest(indexes), target=target, lastIndex=indexMap.(first(indexes)), indexMap=indexMap)><
else
>\<operation kind="noop"\>
	\<port dir="in" source="<target.name>_tmp_<indexMap.(first(indexes))>"/\>
	<typedPort(dir="out", type=target.type, source=target)>
\</operation\><
endif>
>>

sizeDeclare(target,type) ::= <<
<type.dimensions:{dimension|
\<operation kind="$literal_Integer" value="<dimension>"\>
	\<port dir="out" size="32" source="<target.name>_size_<i0>" typeName="int"/\>
\</operation\>}; separator="\n">
>>

///////////////////////////////////////////////////////////////////////////////
// Nodes
///////////////////////////////////////////////////////////////////////////////

printNodes(nodes) ::= <<
<nodes: printNode(); separator="\n">
>>

printNode(node) ::= <<
<if(node.blockNode)><printBlockNode(node)><
elseif(node.ifNode)><printIfNode(node)><
elseif(node.whileNode)><printWhileNode(node)><endif>
>>

printBlockNode(blkNode) ::= <<
<blkNode.instructions: instruction(); separator="\n">
>>

printPhi(instruction) ::= <<
<if(instruction.phi)
><instruction(instruction)><
endif>
>>

printNotPhi(instruction) ::= <<
<if(!instruction.phi)
><instruction(instruction)><
endif>
>>

printPhiNodes(phiNodes) ::= <<
<phiNodes.instructions: printPhi(); separator="\n">
>>

printNotPhiNodes(NotphiNodes) ::= <<
<NotphiNodes.instructions: printNotPhi(); separator="\n">
>>

printIfNode(ifNode) ::= <<
\<module kind="if"\>
	\<module decision="decision_<ifNode.condition>_<ifNode.lineNumber>" kind="test"\>
		\<operation kind="noop"\>
			<untypedPort(dir="in", source=ifNode.condition.use.variable)>
			\<port dir="out" size="1" source="decision_<ifNode.condition>_<ifNode.lineNumber>" typeName="bool"/\>
		\</operation\>
	\</module\>
	\<module kind="then"\>
		<printNodes(ifNode.thenNodes)>
	\</module\><
if(ifNode.elseNodes)
>	\<module kind="else"\>
		<printNodes(ifNode.elseNodes)>
	\</module\><
endif
>	\<!-- joinnode --\>
	<printPhiNodes(ifNode.joinNode)>
\</module\>
<printNotPhiNodes(ifNode.joinNode)>
\<!-- end joinnode --\>
>>

printWhileNode(whileNode) ::= <<
\<module kind="loop"\>
	\<!-- joinnode --\>
	<printPhiNodes(whileNode.joinNode)>
	\<module decision="decision_<whileNode.condition>_<whileNode.lineNumber>" kind="test"\>
		\<!-- Begin joinnode --\>
		<printNotPhiNodes(whileNode.joinNode)>
		\<!-- End joinnode --\>
		\<operation kind="noop"\>
			<untypedPort(dir="in", source=whileNode.condition.use.variable)>
			\<port dir="out" size="1" source="decision_<whileNode.condition>_<whileNode.lineNumber>" typeName="bool"/\>
		\</operation\>
	\</module\>
	\<module kind="body"\>
		<printNodes(whileNode.nodes)>
	\</module\>
\</module\>
>>

///////////////////////////////////////////////////////////////////////////////
// Procedure
///////////////////////////////////////////////////////////////////////////////

procedure(procedure) ::= <<
<if(!procedure.native)
><printNodes(procedure.nodes)><
endif>
>>

///////////////////////////////////////////////////////////////////////////////
// TypeDef
///////////////////////////////////////////////////////////////////////////////

typeDef(action) ::= <<
<action.inputPattern.variables: typeDefLocal()>
<action.outputPattern.variables: typeDefLocal()>
<action.body.locals: typeDefLocal()>
>>

typeDefLocal(local) ::= <<
<if(local.type.list)
>\<typeDef name="<local.name>_typedef"\>
	\<type name="List"\>
		\<valuePar name="size" value="<local.type.size>"/\>
		\<typePar name="type"\>
			<typeDefListElements(local.type.type)>
		\</typePar\>
	\</type\>
\</typeDef\><
endif>
>>

typeDefListElements(type) ::= <<
<if(type.list)
>\<type name="List"\>
	\<valuePar name="size" value="<type.size>"/\>
	\<typePar name="type"\>
		<typeDefListElements(type.type)>
	\</typePar\>
\</type\><
else><
if(type.bool)
>\<type name="<type>"/\><
else
>\<type name="<type>"\>
	\<valuePar name="size" value="<type.size>"/\>
\</type\><
endif><
endif>
>>

///////////////////////////////////////////////////////////////////////////////
// Action
///////////////////////////////////////////////////////////////////////////////

localInitialize(local) ::= <<
<if(local.type.list)
>\<operation kind="$valloc"\>
	<typedPort(dir="out", type=local.type, source=local)>
\</operation\><
endif> 
>>

action(action) ::= <<
\<!-- Action: "<action.name>" --\>
\<module autostart="false" kind="action" name="<action.name>"\>
	<action.outputPattern.variables: localInitialize()>
	<action.body.locals: localInitialize()>
	<action.inputPattern.ports : { port | <printRead(port, action.inputPattern.portToVarMap.(port), action.inputPattern.numTokensMap.(port))> }; separator="\n">
	<procedure(procedure=action.body)>
	<action.outputPattern.ports : { port | <printWrite(port, action.outputPattern.portToVarMap.(port), action.outputPattern.numTokensMap.(port))> }; separator="\n">
\</module\>
>>

///////////////////////////////////////////////////////////////////////////////
// Action scheduler
///////////////////////////////////////////////////////////////////////////////


// Input and output pattern
patternPortPinAvail(dir, port)::= <<
\<!--  <dir>putPattern --\>
\<operation kind="$literal_Integer" value="<pattern.numTokensMap.(port)>"\>
	\<port dir="out" size="32" source="<dir>putPattern_<instance.id>_<action.name>_<port.name>_tokenCount" typeName="int"/\>
\</operation\>
\<operation kind="$ge"\>
	\<port dir="in" source="<port.name>_pinAvail"/\>
	\<port dir="in" source="<dir>putPattern_<instance.id>_<action.name>_<port.name>_tokenCount"/\>
	\<port dir="out" size="1" source="<dir>putPattern_<instance.id>_<action.name>_<port.name>" typeName="bool"/\>
\</operation\>
>>

patternPort(dir, port, index, index0) ::= <<
<patternPortPinAvail(dir=dir, port=port)>
\<operation kind="$and"\>
	\<port dir="in" source="<dir>putPattern_<instance.id>_<action.name>_<port.name>"/\>
	\<port dir="in" source="<dir>putPattern_<instance.id>_<action.name>_res_<index0>"/\>
	\<port dir="out" size="1" source="<dir>putPattern_<instance.id>_<action.name>_res_<index>" typeName="bool"/\>
\</operation\>
>>

outputPatternDecisionState(index, action, state)::=<<
\<module kind="if"\>
	\<module decision="decision_outputPattern_<instance.id>_<action.name>_s_<state.name>_<index>" kind="test"\>
		\<operation kind="noop"\>
			\<port dir="in" source="outputPattern_<instance.id>_<action.name>_res_<index>"/\>
			\<port dir="out" size="1" source="decision_outputPattern_<instance.id>_<action.name>_s_<state.name>_<index>" typeName="bool"/\>
		\</operation\>
	\</module\>
>>

outputPatternDecision(index, action)::=<<
\<module kind="if"\>
	\<module decision="decision_outputPattern_<instance.id>_<action.name>_s__<index>" kind="test"\>
		\<operation kind="noop"\>
			\<port dir="in" source="outputPattern_<instance.id>_<action.name>_res_<index>"/\>
			\<port dir="out" size="1" source="decision_outputPattern_<instance.id>_<action.name>_s__<index>" typeName="bool"/\>
		\</operation\>
	\</module\>
>>

inputPatternDecision(index) ::= <<
\<operation kind="noop"\>
	\<port dir="in" source="inputPattern_<instance.id>_<action.name>_res_<index>"/\>
	\<port dir="out" size="1" source="inputPattern_<instance.id>_<action.name>_decision" typeName="bool"/\>
\</operation\>
>>

pattern(dir, pattern, action) ::= <<
\<operation kind="$literal_Integer" value="1"\>
	\<port dir="out" size="1" source="<dir>putPattern_<instance.id>_<action.name>_res_0" typeName="bool"/\>
\</operation\>
<pattern.ports: {port | <patternPort(dir=dir, port=port, index=i, index0=i0)>}; separator="\n">
>>

outputPattern(pattern, action) ::= <<
<pattern(dir="out", pattern=pattern, action=action)>
>>

inputPattern(pattern, action) ::= <<
<pattern(dir="in", pattern=pattern, action=action)>
\<!-- Last inputPattern --\>
<inputPatternDecision(index=length(pattern.ports)); separator="\n">
>>

// Pin Available declaration

declarePinAvailableVariable(port) ::= <<
\<operation kind="pinAvail" portName="<port.name>"\>
	\<port dir="out" size="32" source="<port.name>_pinAvail" typeName="int"/\>
\</operation\>
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler without FSM

actionCall(action) ::= <<
\<operation kind="taskCall" target="<action.name>"/\>
>>

actionTest(action) ::= <<
\<module kind="if"\>
	\<module decision="decision_isSchedulable_<action.name>" kind="test"\>
		\<operation kind="noop"\>
			\<port dir="in" source="isSchedulable_<action.name>_goWithToken"/\>
			\<port dir="out" size="1" source="decision_isSchedulable_<action.name>" typeName="bool"/\>
		\</operation\>
	\</module\>
	\<module kind="then"\>

		<if(action.outputPattern)
		>\<!-- Last outputPattern --\>
		<outputPatternDecision(index=length(action.outputPattern.ports),action=action); separator="\n">
			\<module kind="then"\>
				<actionCall(action)>
			\</module\>
		\</module\><
		else
		><actionCall(action)><
		endif
	>\</module\>
	\<module kind="else"\>
>>

schedulingTest(actions) ::= <<
\<!-- All Schedulable expressions --\>
<actions: actionTest(); separator="\n">
>>

scheduler(actions) ::= <<
\<module autostart="true" kind="action-scheduler" name="<instance.id>_scheduler" sourcename="<instance.id>_scheduler"\>
	\<module kind="loop"\>
		\<module decision="var_<instance.id>_loop" kind="test"\>
			\<operation kind="$literal_Integer" value="1"\>
				\<port dir="out" size="1" source="var_<instance.id>_sched" typeName="bool"/\>
			\</operation\>
			\<operation kind="noop"\>
				\<port dir="in" source="var_<instance.id>_sched"/\>
				\<port dir="out" size="1" source="var_<instance.id>_loop" typeName="bool"/\>
			\</operation\>
		\</module\>
		\<module kind="body"\>
			\<!-- PinAvail call --\>
			<instance.actor.inputs: {port | <declarePinAvailableVariable(port=port)>}; separator="\n">
			<instance.actor.outputs: {port | <declarePinAvailableVariable(port=port)>}; separator="\n">
    
    		\<!-- All Schedulable expressions --\>
			<instance.actor.actions: isSchedulableTest(); separator="\n">
			<instance.actor.actions: inputPatternTest()>
			<instance.actor.actions: outputPatternTest()>
			<if(actions)><schedulingTest(actions)><endif>
			\<!--Close modules --\>
			<if(actions)><actions:{action|\</module\>\</module\>}; separator="\n"><endif>
		\</module\>
	\</module\>
\</module\>
>>

///////////////////////////////////////////////////////////////////////////////
// Scheduler with FSM

actionCallState(targetState) ::= <<
\<operation kind="assign" target="currentState"\>
	\<port dir="in" source="s_<targetState.name>"/\>
\</operation\>
>>

actionTestState(sourceState, transition) ::= <<
\<module kind="if"\>
	\<module decision="isSchedulable_<transition.action.name>_<sourceState.name>" kind="test"\>
		\<operation kind="noop"\>
			\<port dir="in" source="isSchedulable_<transition.action.name>_goWithToken"/\>
			\<port dir="out" size="1" source="isSchedulable_<transition.action.name>_<sourceState.name>" typeName="bool"/\>
		\</operation\>
	\</module\>
	\<module kind="then"\>
		<if(transition.action.outputPattern)>
		\<!-- Last outputPattern --\>
		<outputPatternDecisionState(length(transition.action.outputPattern.ports), transition.action, sourceState); separator="\n">
			\<module kind="then"\>
				<actionCall(transition.action)>
				<actionCallState(transition.state)>
			\</module\>
		\</module\>
		<else>
		\<!-- no ouput pattern--\>
		<actionCall(transition.action)>
		<actionCallState(transition.state)>
		<endif>
	\</module\>
	\<module kind="else"\>
>>

schedulingTestState(sourceState, transitionsList) ::= <<
<transitionsList: {transition| <actionTestState(sourceState, transition)> }; separator="\n">
<transitionsList: {transition| \</module\>\</module\> }; separator="\n">
>>

printTransition(transitions) ::= <<
\<!-- State s_<transitions.sourceState.name> --\>
\<module kind="if"\>
	\<module decision="s_<transitions.sourceState.name>_enabled" kind="test"\>
		\<operation kind="$eq"\>
			\<port dir="in" source="s_<transitions.sourceState.name>"/\>
			\<port dir="in" source="currentState"/\>
			\<port dir="out" size="1" source="s_<transitions.sourceState.name>_enabled" typeName="bool"/\>
		\</operation\>
	\</module\>
	\<module kind="then"\>
		<schedulingTestState(transitions.sourceState, transitions.list)>
	\</module\>
	\<module kind="else"\>
	<closeHwTransition()>
>>

closeHwTransition() ::=<<
>>

isSchedulableTest(action) ::= <<
<printPeeks(instance.actor.templateData.customPeekedMapPerAction.(action))>
<procedure(action.scheduler)>
>>


outputPatternTest(action) ::= <<
<outputPattern(pattern=action.outputPattern, action=action)>
>>

inputPatternTest(action) ::= <<
<if(action.inputPattern)
><inputPattern(pattern=action.inputPattern, action=action)>
\<operation kind="$and"\>
	\<port dir="in" source="inputPattern_<instance.id>_<action.name>_decision"/\>
	\<port dir="in" source="isSchedulable_<action.name>_go"/\>
	\<port dir="out" size="1" source="isSchedulable_<action.name>_goWithToken" typeName="bool"/\>
\</operation\><
else
>\<operation kind="noop"\>
	\<port dir="in" source="isSchedulable_<action.name>_go"/\>
	\<port dir="out" size="1" source="isSchedulable_<action.name>_goWithToken" typeName="bool"/\>
\</operation\><
endif>
>>

printTransitions(actions, transitionsList) ::= <<
\<!-- All transitions --\>
<transitionsList: {transitions| <printTransition(transitions)> }; separator="\n">
<transitionsList: {transitions| \</module\>\</module\> }; separator="\n">
>>

enumStates(transition)::= <<
\<operation kind="$literal_Integer" value="<instance.actor.templateData.stateToIndexMap.(transition.sourceState)>"\>
	\<port dir="out" size="32" source="s_<transition.sourceState.name>" typeName="int"/\>
\</operation\>
>>

schedulerFSM(actions, fsm) ::= <<

\<!-- Initializing with the initial state "s_<fsm.initialState.name>" --\>
\<stateVar name="currentState"\>
	\<initValue size="32" typeName="int" value="<instance.actor.templateData.stateToIndexMap.(fsm.initialState)>"/\>
\</stateVar\>
\<module autostart="true" kind="action-scheduler" name="<instance.id>_scheduler" sourcename="<instance.id>_scheduler"\>
	\<operation kind="$literal_Integer" value="1"\>
		\<port dir="out" size="1" source="var_<instance.id>_sched" typeName="bool"/\>
	\</operation\>
	\<!-- enumerate states --\>
	<fsm.transitions : {transition | <enumStates(transition=transition)>}; separator="\n">
	\<!-- infinite loop --\>
	\<module kind="loop"\>
	  \<module decision="var_<instance.id>_loop" kind="test"\>
			\<operation kind="noop"\>
				\<port dir="in" source="var_<instance.id>_sched"/\>
				\<port dir="out" size="1" source="var_<instance.id>_loop" typeName="bool"/\>
			\</operation\>
		\</module\>
		\<module kind="body"\>
			\<!-- PinAvail call --\>
			<instance.actor.inputs: {port | <declarePinAvailableVariable(port=port)>}; separator="\n">
			<instance.actor.outputs: {port | <declarePinAvailableVariable(port=port)>}; separator="\n">
    
			\<!-- All Schedulable expressions --\>
			<instance.actor.actions: isSchedulableTest()>
			<instance.actor.actions: inputPatternTest()>
			<instance.actor.actions: outputPatternTest()>
			<if(actions)>			
			\<!-- Untagged actions --\>  	 	 
			<schedulingTest(actions)>  	 
			<endif>
			\<!-- FSM transitions --\>
			<printTransitions(actions, fsm.transitions)>
			<if(actions)>
			\<!--Close modules for untagged actions --\>
			<actions:{action|\</module\>\</module\>}; separator="\n">
			<endif>
		\</module\>
	\</module\>
\</module\>
>>

///////////////////////////////////////////////////////////////////////////////
// Parameters of the Actor
///////////////////////////////////////////////////////////////////////////////

parameters(parameters) ::= <<
<parameters.keys: { k | 
\<stateVar name="<k>" sourceName="<k>"\>
	\<initValue size="<if(parameters.(k).type.bool)>1<else><parameters.(k).type.size><endif>" typeName="<parameters.(k).type>" value="<parameters.(k)>"/\>
\</stateVar\>
}>
>>

///////////////////////////////////////////////////////////////////////////////
// Actor
///////////////////////////////////////////////////////////////////////////////

printHierarchicalPath(path) ::= <<
<path; separator="/">
>>

design(instance) ::= <<
\<!-- /<first(instance.hierarchicalClass)>/<printHierarchicalPath(instance.hierarchicalId)> --\>
\<!-- Source file is "<instance.actor.file>" --\>
\<design name="<instance.id>"\>
	<actorPorts()>
	<parameters(instance.parameters)>
	<stateVars()>
	<instance.actor.actions: typeDef()>
	<instance.actor.actions: action(); separator="\n\n">
	\<!-- ACTION SCHEDULER --\>
	<if(instance.actor.fsm)>
	<schedulerFSM(actions=instance.actor.actionsOutsideFsm, fsm=instance.actor.fsm)>
	<else>
	<scheduler(actions=instance.actor.actionsOutsideFsm)>
	<endif>
\</design\>
>>

instance(instance, options) ::= <<

\<?xml version="1.0" encoding="UTF-8"?\>
<design(instance)>
>>

///////////////////////////////////////////////////////////////////////////////
// Common applet
///////////////////////////////////////////////////////////////////////////////
sendData(port) ::= <<
<if(port.type.bool)
>if (input_bit = 1) then
  <port.name>_data  \<= '1';
else
  <port.name>_data  \<= '0';
end if;<
else
><if(port.type.int)
  ><port.name>_data  \<= std_logic_vector(to_signed(input_bit, <port.type.size>));<
  else
  ><port.name>_data  \<= std_logic_vector(to_unsigned(input_bit, <port.type.size>));<
  endif><
endif>
>>


///////////////////////////////////////////////////////////////////////////////
// Print signal and instanciation
///////////////////////////////////////////////////////////////////////////////
printInPortSignals(port) ::= <<
<if(port.type.bool)
 >signal <port.name>_data  : std_logic := '0';
<else
 >signal <port.name>_data  : std_logic_vector(<port.type.size> -1 downto 0) := (others =\> '0');
<endif>
signal <port.name>_send  : std_logic := '0';
signal <port.name>_ack   : std_logic;
signal <port.name>_rdy   : std_logic;
signal <port.name>_count  : std_logic_vector(15 downto 0) := (others =\> '0');
>>
printOutPortSignals(port) ::= <<
<if(port.type.bool)
 >signal <port.name>_data  : std_logic;
<else
 >signal <port.name>_data  : std_logic_vector(<port.type.size> -1 downto 0);
<endif>
signal <port.name>_send  : std_logic;
signal <port.name>_ack   : std_logic := '0';
signal <port.name>_rdy   : std_logic := '0';
signal <port.name>_count  : std_logic_vector(15 downto 0);
>>

printInPorts(port) ::= <<
<if(port.type.bool)
 ><port.name>_data  : IN std_logic;
<else
 ><port.name>_data  : IN std_logic_vector(<port.type.size> -1 downto 0);
<endif>
<port.name>_send  : IN std_logic;
<port.name>_ack   : OUT std_logic;
<port.name>_rdy   : OUT std_logic;
<port.name>_count  : IN std_logic_vector(15 downto 0);
>>

printOutPorts(port) ::= <<
<if(port.type.bool)
 ><port.name>_data  : OUT std_logic;
<else
 ><port.name>_data  : OUT std_logic_vector(<port.type.size> -1 downto 0);
<endif>
<port.name>_send  : OUT std_logic;
<port.name>_ack   : IN std_logic;
<port.name>_rdy   : IN std_logic;
<port.name>_count  : OUT std_logic_vector(15 downto 0);
>>

signalsInstanciation(port) ::= <<
<port.name>_data  =\> <port.name>_data,
<port.name>_send  =\> <port.name>_send,
<port.name>_ack   =\> <port.name>_ack,
<port.name>_count   =\> <port.name>_count,
<port.name>_rdy   =\> <port.name>_rdy
>>

ActorInputSignalsInstanciation(port) ::= <<
<port.name>_data  =\> <port.name>_data,
<port.name>_send  =\> <port.name>_send,
<port.name>_ack   =\> <port.name>_ack,
<port.name>_count   =\> <port.name>_count
>>

waveform_process_in(input) ::= <<
--
-- Input(s) Waveform Generation
WaveGen_Proc_In : process (clock)
  variable Input_bit   : integer range 2147483647 downto - 2147483648;
  variable line_number : line;
begin
  if rising_edge(clock) then 
    <input: case_define_in(); separator="\n">
  end if;
end process WaveGen_Proc_In;

>>

case_define_in(port) ::= <<
<if (!port.native)
>--
-- Input port: <port.name> Waveform Generation
case tb_FSM_<port.name> is
  when after_reset =\>
    count \<= count + 1;
    if (count = 15) then
      tb_FSM_<port.name> \<= read_file;
      count           \<= 0;
    end if;

  when read_file =\>
    if (not endfile (sim_file_<instance.id>_<port.name>)) then
      readline(sim_file_<instance.id>_<port.name>, line_number);
      --
      if (line_number'length \> 0 and line_number(1) /= '/') then
        read(line_number, input_bit);
        <sendData(port)>
        <port.name>_send \<= '1';    
        tb_FSM_<port.name> \<= CheckRead;
      end if;
    end if;

  when CheckRead =\>
    if (not endfile (sim_file_<instance.id>_<port.name>)) and <port.name>_ack = '1' then
      readline(sim_file_<instance.id>_<port.name>, line_number);
      --
      if (line_number'length \> 0 and line_number(1) /= '/') then
        read(line_number, input_bit);
        <sendData(port)>
        <port.name>_send \<= '1';      
      end if;
    elsif (endfile (sim_file_<instance.id>_<port.name>)) then
      <port.name>_send \<= '0'; 
    end if;

  when others =\> null;
end case;
<endif>

>>


waveform_process_out(output) ::= <<
-- Output(s) waveform Generation
<output: {port|<port.name>_ack \<= <port.name>_send;}; separator="\n">
<output: {port|<port.name>_rdy \<= '1';}; separator="\n">    
--
WaveGen_Proc_Out : process (clock)
  variable Input_bit   : integer range 2147483647 downto - 2147483648;
  variable line_number : line;
begin
  if (rising_edge(clock)) then
    <output: case_define_out(); separator="\n">
  end if;
end process WaveGen_Proc_Out;

>>

printFSMIn(connection) ::= <<
signal tb_FSM_<connection.targetPort.name>  : tb_type;
file sim_file_<instance.simpleName>_<connection.targetPort.name>  : text is "fifoTraces/<connection.source.simpleName>_<connection.sourcePort.name>_<connection.target.simpleName>_<connection.targetPort.name>_traces.txt";
>>

printFSMOut(connection) ::= <<
file sim_file_<instance.simpleName>_<connection.sourcePort.name>  : text is "fifoTraces/<connection.source.simpleName>_<connection.sourcePort.name>_<connection.target.simpleName>_<connection.targetPort.name>_traces.txt";
>>

case_define_out(port) ::= <<
--
-- Output port: <port.name> Waveform Generation
if (not endfile (sim_file_<instance.id>_<port.name>) and <port.name>_send = '1') then
  readline(sim_file_<instance.id>_<port.name>, line_number);
  --
  if (line_number'length \> 0 and line_number(1) /= '/') then
    read(line_number, input_bit);
<
if(port.type.bool)
>    if (input_bit = 1) then
      assert (<port.name>_data = '1')
        report "on port <port.name> incorrectly value computed : '0' instead of : '1'"
        severity error;
        
        assert (<port.name>_data = '0')
        report "on port <port.name> correct value computed : '1' equals : '1'"
        severity note;
    else
      assert (<port.name>_data = '0')
        report "on port <port.name> incorrectly value computed : '1' instead of : '0'"
        severity error;
        
        assert (<port.name>_data = '1')
        report "on port <port.name> correct value computed : '0' equals : '0'"           
        severity note;     
    end if;<
else
><if(port.type.int)
  >    assert (<port.name>_data  = std_logic_vector(to_signed(input_bit, <port.type.size>)))
      -- report "on <port.name> incorrectly value computed : " & to_string(to_integer(to_signed(<port.name>_data))) & " instead of :" & to_string(input_bit)
      report "on port <port.name> incorrectly value computed : " & str(to_integer(signed(<port.name>_data))) & " instead of :" & str(input_bit)
      severity error;
      
      assert (<port.name>_data /= std_logic_vector(to_signed(input_bit, <port.type.size>)))
      -- report "on <port.name> incorrectly value computed : " & to_string(to_integer(to_signed(<port.name>_data))) & " equals :" & to_string(input_bit)
      report "on port <port.name> correct value computed : " & str(to_integer(signed(<port.name>_data))) & " equals :" & str(input_bit)
      severity note;
      
  <else
  >    assert (<port.name>_data  = std_logic_vector(to_unsigned(input_bit, <port.type.size>)))
      --report "on port <port.name> incorrectly value computed : " & to_string(to_integer(to_unsigned(<port.name>_data))) & " instead of :" & to_string(input_bit)
      report "on port <port.name> incorrectly value computed : " & str(to_integer(unsigned(<port.name>_data))) & " instead of :" & str(input_bit)
      severity error;
      
      assert (<port.name>_data /= std_logic_vector(to_unsigned(input_bit, <port.type.size>)))
      --report "on port <port.name> incorrectly value computed : " & to_string(to_integer(to_unsigned(<port.name>_data))) & " equals :" & to_string(input_bit)
      report "on port <port.name> correct value computed : " & str(to_integer(unsigned(<port.name>_data))) & " equals :" & str(input_bit)
      severity note;
      
  <endif
  ><endif
>    --
  end if;
end if;

>>
///////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////
// the dimensions of a list: [dim1][dim2]...[dimn]
// does not output anything if <value> is empty

sig_const(input, output, incoming, outgoing) ::= <<
constant PERIOD : time := 50 ns;
constant DUTY_CYCLE : real := 0.5;
constant OFFSET : time := 100 ns;
--
type severity_level is (note, warning, error, failure);
type tb_type is (after_reset, read_file, CheckRead);
--
-- Input and Output files
<incoming: printFSMIn(); separator="\n">
<outgoing: printFSMOut(); separator="\n">
--
-- Input and Output signals
<input: printInPortSignals(); separator="\n">
<output: printOutPortSignals(); separator="\n">
--
-- Configuration
signal count       : integer range 255 downto 0 := 0;
signal clock       : std_logic := '0';
signal reset_n     : std_logic := '0';

>>

///////////////////////////////////////////////////////////////////////////////
// Print processes
///////////////////////////////////////////////////////////////////////////////
clock_process() ::= <<
clockProcess : process
        begin
            wait for OFFSET;
            clock_LOOP : loop
                clock \<= '0';
                wait for (PERIOD - (PERIOD * DUTY_CYCLE));
                clock \<= '1';
                wait for (PERIOD * DUTY_CYCLE);
            end loop clock_LOOP;
        end process;

>>

RESET_process() ::= <<
resetProcess : process
   begin		
	 wait for OFFSET;
      -- reset state for 100 ns.
		reset_n \<= '1';
      wait for 100 ns;
      reset_n \<= '0';	
		wait;
   end process;

>>

///////////////////////////////////////////////////////////////////////////////
// testbench
///////////////////////////////////////////////////////////////////////////////
printInstance(instance, options) ::= <<
------------------------------------------------------------------------------
-- Generated from <instance.id>
------------------------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.std_logic_unsigned.all;
USE ieee.numeric_std.ALL;
USE std.textio.all;

library work;
use work.sim_package.all;

entity <instance.simpleName>_tb is

end <instance.simpleName>_tb;


architecture arch_<instance.simpleName>_tb of <instance.simpleName>_tb is 

<if(instance.actor)>

----------------------------------------------------------------------------
-- component declaration
----------------------------------------------------------------------------

component <instance.simpleName>
	port (
     
      <if(instance.actor.inputs || instance.actor.outputs)><endif>
      <instance.actor.inputs: printInPorts(); separator="\n"><if(instance.actor.inputs && instance.actor.outputs)><endif>
      <instance.actor.outputs: printOutPorts(); separator="\n"><if(!instance.actor.outputs)>    <endif>
      CLK : IN std_logic;
      RESET : IN std_logic);
      end component;

  ---------------------------------------------------------------------------
  -- Signal & constant declaration
  --------------------------------------------------------------------------- 
  <sig_const(input=instance.actor.inputs,output=instance.actor.outputs,incoming=instance.incoming,outgoing=instance.outgoing)>
  ---------------------------------------------------------------------------

begin

	uut : <instance.id> port map (
    CLK      =\> clock,
    RESET    =\> reset_n<if(instance.actor.inputs || instance.actor.outputs)>,<endif>
    <instance.actor.inputs: ActorInputSignalsInstanciation(); separator=",\n"><if(instance.actor.inputs && instance.actor.outputs)>,<endif>
    <instance.actor.outputs: signalsInstanciation(); separator=",\n"><if(!instance.actor.outputs)>    <endif>);
      
       
    <clock_process()>
    
    <RESET_process()>
    
    <if(instance.actor.inputs)
    ><waveform_process_in(input=instance.actor.inputs)><
    endif>
    <if(instance.actor.outputs)
    ><waveform_process_out(output=instance.actor.outputs)><
    endif>
<else>

----------------------------------------------------------------------------
-- component declaration
----------------------------------------------------------------------------

component <instance.id>
	port (
     
      <if(instance.network.inputs  || instance.network.outputs )><endif>
      <instance.network.inputs : printInPorts(); separator="\n"><if(instance.network.inputs  && instance.network.outputs )><endif>
      <instance.network.outputs : printOutPorts(); separator="\n"><if(!instance.network.outputs )>    <endif>
      CLK : IN std_logic;
      RESET : IN std_logic);
      end component;
  ---------------------------------------------------------------------------
  -- Signal & constant declaration
  --------------------------------------------------------------------------- 
  <sig_const(input=instance.network.inputs ,output=instance.network.outputs,incoming=instance.incoming,outgoing=instance.outgoing)>
  ---------------------------------------------------------------------------

begin

   uut : <instance.simpleName> port map (
      CLK      =\> clock,
      RESET    =\> reset_n<if(instance.network.inputs  || instance.network.outputs )>,<endif>
      <instance.network.inputs : signalsInstanciation(); separator=",\n"><if(instance.network.inputs  && instance.network.outputs )>,<endif>
      <instance.network.outputs : signalsInstanciation(); separator=",\n"><if(!instance.network.outputs )>    <endif>);
      
    <clock_process()>

    <RESET_process()>
    
    <if(instance.network.inputs )
    ><waveform_process_in(input=instance.network.inputs)><
    endif>
    <if(instance.network.outputs )
    ><waveform_process_out(output=instance.network.outputs)><
    endif>
<endif>

end architecture arch_<instance.simpleName>_tb;
>>